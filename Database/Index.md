# 인덱스

검색 속도 향상을 목적으로 만드는 하나 이상의 테이블 필드에 대한 자료구조  
대표적인 자료구조는 해시 테이블과 B-Tree가 사용된다.  
각 노드에는 키로써 인덱스 값이 포함되어 있고 인덱스 값을 탐색하면 실제 데이터가 저장된 위치를 알 수 있다.  
B-Tree의 경우 특성상 다량의 노드에 대한 빠른 검색이 가능하기 때문에 인덱스를 바탕으로 레코드가 저장된 위치를 빠르게 알 수 있다.

---

# MySQL에서의 인덱스 종류

## 클러스터형 인덱스
- 테이블당 하나씩 만들 수 있는 인덱스로 기본키가 이에 해당한다.  
- 테이블 내에 기본 키로 지정된 필드는 기본적으로 클러스터형 인덱스로 간주된다.  
- 기본키로 지정된 필드가 없을 경우 NOT NULL 제약 조건과 UNIQUE 제약 조건이 있는 필드를 클러스터형 인덱스로 간주한다.

## 세컨더리 인덱스(논클러스터형 인덱스)
- 클러스터형 인덱스가 아닌 인덱스  
- 테이블 당 여러 개가 존재할 수 있지만 클러스터형 인덱스를 활용한 검색보다 일반적으로 느리다.

### 인덱스 관련 SQL

```sql
-- '테이블 이름'의 '필드'에 세컨더리 인덱스인 '인덱스_이름'을 생성
CREATE INDEX 인덱스_이름 ON 테이블_이름 (필드);

-- 인덱스 조회
SHOW INDEX FROM 테이블_이름;

-- 인덱스 삭제
DROP INDEX 인덱스_이름 FROM 테이블_이름;
```
---
## 인덱스의 활용

인덱스는 기본적으로 검색 속도를 향상시켜주지만 모든 필드에 대해 인덱스를 생성하지 않는다.  
인덱스 생성하기 전에 저장 공간과 생성 시간이라는 기회 비용을 고려해야한다.

인덱스는 조회 성능은 향상 시킬 수 있지만 그 외의 작업인 INSERT, UPDATE, DELETE에 대해서는 성능을 떨어뜨리기도 한다.  
-> 새로운 데이터를 삽입하거나 기존 데이터를 수정/삭제할 때 인덱스에 대한 작업도 동시에 이루어져야하기 때문

인덱스를 사용할 때는 데이터가 충분히 많고 조회가 빈번히 이루어지는 테이블 필드에 만들어 활용해야한다.  
또한, 카디널리티가 높은 필드에 대해 인덱스를 적용하는 것이 효과적이다.

