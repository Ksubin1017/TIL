# 컬렉션 프레임워크
자료구조를 바탕으로 객체들을 효율적으로 추가, 삭제, 검색할 수 있도록 관련된 인터페이스와 클래스들을
java.util 패키지에 포함 시켰고 이들을 총칭해서 컬렉션 프레임워크라고 한다.

## List
객체를 인덱스로 관리하며 객체를 저장하면 인덱스가 부여되고 인덱스를 통해 객체를 검색, 삭제할 수 있는 기능 제공
객체 자체를 저장하는 것이 아닌 객체의 번지를 저장하며 동일한 객체를 중복 저장할 수 있다.
이 경우 동일한 번지가 저장되고 null 저장도 가능하다.

### ArrayList
ArrayList에 객체를 추가하면 내부 배열에 객체가 저장되고 일반 배열과 달리 제한 없이 객체 추가가 가능하다.

객체를 추가하면 인덱스 0부터 차례대로 저장, 특정 인덱스 제거 시 바로 뒤 인덱스부터 마지막 인덱스까지 모두 앞으로 1씩 당겨진다.
삽입 시 해당 인덱스부터 마지막 인덱스까지 모두 1씩 밀려난다.

따라서 삽입과 삭제가 빈번이 일어나는 곳은 ArrayList는 지양해야한다.

### Vector
ArrayList와 동일한 내부 구조를 가지고 있지만 동기화된 메서드로 구성되어 있기 때문에 멀티 스레드가 동시에 Vector 메서드를 실행 할 수 없다.

### LinkedList
ArrayList와 사용 방법은 동일하지만 내부 구조가 다르다. LinkedList는 인접 객체를 체인처럼 연결해서 관리한다.
특정 위치에서 객체를 삽입하거나 삭제하면 바로 앞뒤 링크만 변경하면 되기 때문에 객체 삽입 및 삭제가 자주 발생하는 곳에서 ArrayList보다 성능이 좋다.

## Set
저장 순서가 유지되지 않으며 객체를 중복해서 저장할 수 없다.(null 또한 하나만 저장 가능)
인덱스로 관리되지 않기 때문에 객체를 검색하려면 객체를 한 개씩 반복해서 가져와야한다.

### HashSet
동일한 객체(동등 객체)는 중복 저장하지 않는다.
다른 객체라도 hashCode()의 리턴값이 같고 equals()가 true를 리턴하면 동일한 객체로 판단하고 중복 저장하지 않는다.

## Map
키(key)와 값(value)로 구성된 엔트리 객체를 저장한다.
키는 중복 저장이 불가능하며 값은 중복 저장이 가능하다.
기존에 저장된 키와 동일한 키로 값을 저장하면 새로운 값이 기존 값을 덮어쓴다.

### HashMap
키로 사용할 객체가 hashCode(0 리턴값이 같고 equals()가 true를 리턴하면 동일 키로 판단해 중복 저장을 허용하지 않는다.

### HashTable
HashMap과 동일한 내부 구조를 가지고 있지만 동기화된 메서드로 구성되어 있어 멀티 스레드가 동시에 HashTable의 메서드들을 실행할 수 없다.

## Tree

### TreeSet
이진 트리를 기반으로 한 Set 컬렉션으로 부모 노드의 객체와 비교해서 낮은 것은 왼쪽 자식 노드, 높은 것은 오른쪽 자식 노드에 저장한다.

### TreeMap
이진 트리를 기반으로 한 Map 컬렉션으로 키와 값이 저장된 엔트리를 저장한다.
키를 기준으로 부모 키와 비교해서 낮은 것은 왼쪽, 높은 것은 오른쪽 자식 노드에 엔트리 객체를 저장한다.

## LIFO와 FIFO 컬렉션
후입선출(LIFO), 선입선출(FIFO)를 구현한 컬렉션

### Stack
LIFO 자료구조를 구현한 클래스

### Queue
FIFO 자료구조에서 사용되는 메서드를 정의한 인터페이스
