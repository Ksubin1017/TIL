# JVM이란?
Java Virtual Machine의 약자로, 자바 프로그램을 실행시키기 위한 가상 머신이다. 자바 바이트 코드를 운영체제가 이해할 수 있는 기계어로 번역하여 실행힌다.
JVM은 운영체제에 종속되지 않고 동일한 바이트코드(.class)를 실행할 수 있도록 설계되어 있기 때문에 운영체제와 독립적으로 실행된다.
# JVM 구성 요소
## 클래스 로더
JVM 내로 클래스 파일(`.class`)을 동적으로 로드하고 **링크(Linking)** 를 통해 배치하는 작업을 수행하는 모듈.  
로드된 바이트 코드(`.class`)는 JVM의 메모리 영역인 **Runtime Data Area**에 배치되며, 애플리케이션에서 필요한 경우 동적으로 메모리에 로드된다.  
- **로딩 방식**  
  - 클래스를 한 번에 모두 메모리에 올리지 않고, 애플리케이션에서 **필요할 때 동적으로 적재**한다.  
---
### 클래스 로딩 과정 (3단계)
1. **Loading (로드)**  
   - 클래스 파일을 가져와서 JVM 메모리에 로드한다.  
2. **Linking (링크)**  
   - **Verifying (검증)**: 읽어들인 클래스가 JVM 명세에 맞게 구성되어 있는지 검사  
   - **Preparing (준비)**: 클래스가 필요로 하는 메모리를 할당  
   - **Resolving (분석)**: 클래스의 상수 풀(Constant Pool) 내 모든 **심볼릭 레퍼런스**를 **다이렉트 레퍼런스**로 변경  
     - `.class` 파일에는 로드 시점마다 달라지는 실제 메모리 주소를 담을 수 없으므로, **심볼(이름)** 을 저장해둔다.  
     - 로드 시점에 해당 심볼을 실제 메모리 위치에 매핑한다.  
     - 심볼릭 레퍼런스만 남아 있으면 매번 힙에서 탐색해야 하지만, 다이렉트 레퍼런스로 바꾸면 곧바로 메모리 주소에 접근할 수 있어 성능이 향상된다.  
3. **Initialization (초기화)**  
   - 클래스 변수(`static 필드`)들을 설정된 값으로 초기화한다.  
  
## 실행 엔진
- 클래스 로더를 통해 런타임 데이터 영역에 배치된 바이트 코드를 명령어 단위로 읽어서 실행  
- 자바 `.class`의 코드는 가상머신이 이해할 수 있는 중간 레벨의 컴파일 코드로, 기계가 바로 수행 불가  
- 실행 엔진은 바이트 코드를 실제로 JVM 내부에서 기계가 실행할 수 있는 형태로 변경  
- 인터프리터와 JIT 컴파일러 두 가지 방식을 혼합하여 바이트 코드를 실행  
### 인터프리터
- 바이트 코드 명령어를 한 줄씩 읽어 해석하고 바로 실행  
- JVM 내에서 바이트 코드는 기본적으로 인터프리터 방식으로 동작  
- 같은 메서드라도 매번 해석해야 해서 속도는 느림  
### JIT 컴파일러
- 인터프리터의 단점을 보완하기 위해 도입  
- 반복되는 코드가 컴파일 호출 횟수 임계값을 넘으면 컴파일 대상으로 선정  
- 해당 바이트 코드 전체를 네이티브 코드로 컴파일하여 **메모리(코드 캐시)**에 저장  
- 이후 해당 메서드는 인터프리팅하지 않고 캐싱된 네이티브 코드로 직접 실행  
### GC (Garbage Collector)
- 힙 메모리 영역에서 사용되지 않는 메모리를 회수  
## 런타임 데이터 영역
- **메서드 영역**  
- **스택 영역**  
- **힙 영역**  
