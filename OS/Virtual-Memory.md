## 물리주소와 논리주소

- **물리 주소**: 메모리의 하드웨어 상 실제 주소  
- **논리 주소**: 프로세스마다 부여되는 0번지부터 시작하는 주소 체계  

CPU와 프로세스가 사용하는 주소 체계는 논리 주소이므로 논리 주소는 중복될 수 있다.  
논리 주소가 하드웨어 상의 메모리와 상호작용하기 위해서 논리 주소를 물리 주소 간 변환이 이루어져야 하는데  
이 역할을 하는 하드웨어가 **메모리 관리 장치(MMU, Memory Management Unit)** 다.

---

## 스와핑

프로세스를 임시로 보조기억장치의 일부 영역인 **스왑 영역(swap area)** 으로 이동하고 메모리의 빈 공간에 다른 프로세스를 적재하여 실행하는 메모리 관리 방식

- **스왑 아웃(swap-out)**: 현재 실행 중이지 않는 프로세스가 스왑 영역으로 이동되는 것  
- **스왑 인(swap-in)**: 스왑 영역에 있는 프로세스가 다시 메모리로 옮겨오는 것  

운영체제는 스와핑을 통해 프로세스들을 메모리 내 빈 공간에 적재하는데 빈 공간이 여러 개일 때 프로세스를 할당하는 방법이 필요하다.

---

## 연속 메모리 할당

프로세스에 **연속적인 메모리 공간을 할당하는 방식**

스와핑 과정에서 메모리에는 군데군데 계속해서 빈 공간이 생기는데 연속 메모리 할당은 **외부 단편화** 문제가 발생할 수 있다.

### 연속 메모리 할당의 외부 단편화

[프로세스A 50MB] - [프로세스B 30MB] - [프로세스C 100MB]

1. 프로세스B 스왑 아웃(메모리 빈 공간 30MB 생성)  
2. 프로세스D 40MB 할당  
3. 프로세스B가 스왑 아웃된 빈 공간은 활용 불가  

위 과정처럼 프로세스 바깥에 빈 공간에 그보다 큰 프로세스를 적재할 수 없어 메모리 낭비가 생기는 현상을 **외부 단편화**라고 한다.

---

## 가상 메모리

프로그램 일부만 메모리에 적재해 실제 메모리보다 더 큰 프로세스를 실행할 수 있는 메모리 관리 기법

스와핑과 연속 메모리 할당은 적재와 삭제가 반복되면서 프로세스들 사이에 발생하는 외부 단편화와 물리 메모리보다 큰 프로세스를 실행할 수 없다는 문제가 존재
-> **가상 메모리 방식** 사용

---

## 페이징

프로세스의 논리 주소 공간을 일정한 단위인 **페이지(Page)** 로 나누고 물리 주소 공간을 **프레임(Frame)** 으로 나누어 페이지를 프레임에 할당하는 **가상 메모리 관리 기법**

페이지라는 일정한 크기로 잘린 프로세스들을 메모리에 불연속적으로 할당하여 외부 단편화의 발생을 방지할 수 있다.  

또한 스와핑이 사용될 수 있는데 프로세스 전체가 아닌 페이지 단위로 페이지 인(스왑 인)/페이지 아웃(스왑 아웃)이 된다.  
프로세스 일부만 페이지 인 되고 일부는 페이지 아웃된다면,
즉, 프로세스 일부는 메모리, 일부는 보조기억장치에 적재된다면 프로세스를 실행하기 위해 전체 프로세스가 메모리에 적재될 필요가 없다.

---

## 페이징의 내부 단편화

모든 프로세스가 페이지 크기에 맞게 분할되지는 않는다.

1. 페이지는 10KB 용량  
2. 프로세스 총 용량 107KB  
3. 마지막 페이지의 경우 7KB만 적재되어 3KB가 낭비  

이처럼 페이지 하나의 크기보다 작은 크기의 프로세스가 적재되면서 페이지 내부에 메모리 낭비가 발생하는 것을 **내부 단편화**라고 한다.
