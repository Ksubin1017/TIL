# 스프링 컨테이너
객체(빈)를 직접 생성하고 관리해주는 역할
개발자는 new로 객체를 만들지 않고 스프링에게 필요한 객체를 요청하면 된다.

## 사용 이유
객체 생성 책임이 개발자 -> 스프링으로 넘어감(제어의 역전, IOC)

- 객체를 직접 생성하지 않기 때문에 객체 간 결합도가 낮아진다.
<br>-> <br>객체를 생성하려면 new 생성자를 사용해야한다. 애플리케이션에는 수많은 객체가 존재하고 서로 참조하게 되는데
객체 간 참조가 많으면 의존성이 높아지게 된다. 스프링 컨테이너를 사용하면 구현체의 의존성을 제거하고 인터페이스에만 의존하도록 설계가 가능하다.

- 구현체를 바꿔도 구현체를 사용하는 쪽 코드는 수정이 거의 일어나지 않고 가짜 객체를 주입할 수 있어 테스트가 쉬워진다.
<br>-> 유지보수 + 확장성이 좋아짐

## 역할
- 빈 생성
<br>`@Component`, `@Controller`, `@Service`, `@Repository` 등으로 등록된 객체를 생성한다.

- 의존성 주입(DI)
<br>`@Autowired`, 생성자 주입 등을 통해 필요한 객체를 자동으로 연결한다.

- 빈 생명주기 관리
<br>빈의 [생성 -> 초기화 -> 사용 -> 소멸]의 생명주기를 관리한다.

 - 싱글톤 관리
<br>빈은 하나만 생성해서 공유한다.
<br>싱글톤으로 관리하지 않게 되면 사용자의 요청마다 새로운 객체를 생성하기 때문에 메모리에 부담이 생긴다.
<br>스프링 컨테이너는 기본적으로 빈을 싱글톤으로 관리해 요청에 같은 객체를 공유한다.
<br>싱글톤으로 관리하기 때문에 공유 상태를 가지는 인스턴스 변수를 선언하면 레이스 컨디션 문제가 발생할 수 있다.
<br>싱글톤 빈은 여러 스레드가 동시에 접근하므로, 반드시 무상태(stateless)로 설계해야 한다.

```java
@Service
public class OrderService {

    private int orderCount = 0; // ❌ 공유 상태 (인스턴스 변수)

    public void order() {
        orderCount++; //
    }

    public int getOrderCount() {
        return orderCount;
    }
}

```

## ApplicationContext
스프링 컨테이너의 중앙 관리자 역할
<br>단순히 빈을 담아두는 저장소가 아닌 애플리케이션 전반의 인프라를 관리하는 객체

### 주요 책임
- 설정 정보 해석
<br>@Configuration, @ComponentScan, XML 설정 등을 읽어 스프링 설정을 구성한다.

- 컴포넌트 스캔 실행 주체
<br>지정된 패키지를 스캔하여 @Component 계열 어노테이션이 붙은 클래스를 빈으로 등록한다.

- 빈 조회 및 제공
<br>타입 또는 이름을 통해 필요한 빈을 조회해 제공한다.

- 애플리케이션 이벤트 관리
<br>이벤트 발행 및 리스너를 관리하여 컴포넌트 간 느슨한 결합을 지원한다.

- 리소스 및 환경 정보 제공
<br>프로파일, 환경 변수, 설정 값 등을 통합적으로 관리한다.

### Application Context vs BeanFactory
ApplicationContext는 BeanFactory를 확장한 인터페이스로 BeanFactory의 기본 기능에 다양한 부가 기능을 포함한다.

- 국제화(i18n)
- 애플리케이션 이벤트
- 리소스 로딩
- 환경 변수 및 프로파일 처리
